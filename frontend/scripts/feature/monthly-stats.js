// ===================== MONTHLY ROOM STATS MODULE =====================
// File: monthly-room-stats.js - Th·ªëng k√™ th√°ng theo ph√≤ng

class MonthlyRoomStats {
    constructor() {
        this.monthlyData = {};
        this.monthLabels = {};
        this.roomMembers = {}; // L∆∞u s·ªë l∆∞·ª£ng th√†nh vi√™n m·ªói ph√≤ng
    }

    // Helper: L·∫•y key th√°ng t·ª´ ng√†y (YYYY-MM)
    getMonthKey(date) {
        const d = new Date(date);
        return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
    }

    // Helper: L·∫•y label th√°ng hi·ªÉn th·ªã
    getMonthLabel(monthKey) {
        const [year, month] = monthKey.split('-');
        const monthNames = [
            'Th√°ng 1', 'Th√°ng 2', 'Th√°ng 3', 'Th√°ng 4', 'Th√°ng 5', 'Th√°ng 6',
            'Th√°ng 7', 'Th√°ng 8', 'Th√°ng 9', 'Th√°ng 10', 'Th√°ng 11', 'Th√°ng 12'
        ];
        return `${monthNames[parseInt(month) - 1]} - ${year}`;
    }

    // Load d·ªØ li·ªáu t·ª´ Firestore v√† t√≠nh to√°n theo th√°ng
    async loadMonthlyData(students) {
        if (typeof db === 'undefined') {
            console.warn("‚ö†Ô∏è Firestore ch∆∞a s·∫µn s√†ng, kh√¥ng th·ªÉ load th·ªëng k√™ th√°ng.");
            return;
        }

        console.log("üîÑ MonthlyRoomStats: ƒêang t·∫£i d·ªØ li·ªáu t·ª´ Firestore...");
        const snapshot = await db.collection("cham_phong_9").orderBy("createdAt").get();

        this.monthlyData = {};
        this.monthLabels = {};
        this.roomMembers = {};

        // ƒê·∫øm s·ªë th√†nh vi√™n m·ªói ph√≤ng
        const roomMemberCount = {};
        students.forEach(student => {
            if (!roomMemberCount[student.room]) {
                roomMemberCount[student.room] = 0;
            }
            roomMemberCount[student.room]++;
        });
        this.roomMembers = roomMemberCount;

        snapshot.forEach(doc => {
            const data = doc.data();
            if (!data.nguoiTruc || !data.createdAt || !data.room) return;

            let dateObj;
            if (typeof data.createdAt === 'string') {
                dateObj = new Date(data.createdAt);
            } else if (data.createdAt.toDate) {
                dateObj = data.createdAt.toDate();
            } else {
                return;
            }

            const monthKey = this.getMonthKey(dateObj);
            const monthLabel = this.getMonthLabel(monthKey);

            if (!this.monthlyData[monthKey]) this.monthlyData[monthKey] = {};
            this.monthLabels[monthKey] = monthLabel;

            const room = data.room;
            if (!this.monthlyData[monthKey][room]) {
                this.monthlyData[monthKey][room] = {
                    room: room,
                    diemTrucPhong: [], // ƒêi·ªÉm tr·ª±c c·ªßa ph√≤ng (t·ª´ form ch·∫•m)
                    diemPhatCaNhan: [] // ƒêi·ªÉm ph·∫°t c√° nh√¢n c·ªßa t·∫•t c·∫£ th√†nh vi√™n
                };
            }

            // T√≠nh ƒëi·ªÉm tr·ª±c ph√≤ng t·ª´ form ch·∫•m
            const diemTrucNgay = this.calculateDailyRoomScore(data);
            this.monthlyData[monthKey][room].diemTrucPhong.push(diemTrucNgay);

            // T√≠nh ƒëi·ªÉm ph·∫°t c√° nh√¢n cho t·∫•t c·∫£ th√†nh vi√™n trong ph√≤ng (tr·ª´ ng∆∞·ªùi tr·ª±c)
            const roomStudents = students.filter(s => s.room === room);
            roomStudents.forEach(student => {
                // Kh√¥ng t√≠nh ƒëi·ªÉm ph·∫°t cho ng∆∞·ªùi tr·ª±c trong ng√†y ƒë√≥
                if (student.name !== data.nguoiTruc && student.mssv !== data.nguoiTruc) {
                    const diemPhatCaNhan = this.calculatePersonalViolations(data, student.name);
                    if (diemPhatCaNhan > 0) {
                        this.monthlyData[monthKey][room].diemPhatCaNhan.push(diemPhatCaNhan);
                    }
                }
            });
        });

        console.log("‚úÖ MonthlyRoomStats: Ho√†n t·∫•t load d·ªØ li·ªáu th√°ng", this.monthlyData, this.monthLabels);
    }

    // T√≠nh ƒëi·ªÉm tr·ª±c ph√≤ng t·ª´ form ch·∫•m (t·∫•t c·∫£ ti√™u ch√≠)
    calculateDailyRoomScore(data) {
        let totalScore = 0;
        let itemCount = 0;
        
        // Duy·ªát qua t·∫•t c·∫£ c√°c field trong form
        Object.keys(data).forEach(key => {
            // B·ªè qua c√°c field kh√¥ng ph·∫£i ƒëi·ªÉm ch·∫•m
            if (['nguoiTruc', 'room', 'createdAt', 'ghiChu', 'serverTimestamp'].includes(key)) {
                return;
            }
            
            const value = data[key];
            if (value === 'ƒê·∫°t' || value === '"ƒê·∫°t"') {
                totalScore += 1;
                itemCount++;
            } else if (value === 'Kh√¥ng ƒë·∫°t' || value === '"Kh√¥ng ƒë·∫°t"') {
                totalScore += 0;
                itemCount++;
            }
        });
        
        // Tr·∫£ v·ªÅ ƒëi·ªÉm trung b√¨nh (scale 0-55)
        return itemCount > 0 ? (totalScore / itemCount) * 55 : 0;
    }

    // T√≠nh ƒëi·ªÉm ph·∫°t c√° nh√¢n t·ª´ vi ph·∫°m khu v·ª±c c√° nh√¢n
    calculatePersonalViolations(data, studentName) {
        let violations = 0;
        
        // C√°c key li√™n quan ƒë·∫øn c√° nh√¢n
        const personalKeys = [
            `giuong_${studentName}`,
            `ghe_${studentName}`,
            `tu_${studentName}`,
            `keSach_${studentName}`,
            `mocTreoDo_${studentName}`
        ];
        
        personalKeys.forEach(key => {
            if (data[key] && (data[key] === 'Kh√¥ng ƒë·∫°t' || data[key] === '"Kh√¥ng ƒë·∫°t"')) {
                violations += 1; // M·ªói vi ph·∫°m = 1 ƒëi·ªÉm ph·∫°t
            }
        });
        
        return violations;
    }

    // T√≠nh to√°n ƒëi·ªÉm cu·ªëi c√πng cho m·ªói ph√≤ng trong th√°ng
    calculateMonthlyRoomStats(monthData) {
        const results = [];
        
        Object.entries(monthData).forEach(([room, data]) => {
            // T·ªïng ƒëi·ªÉm tr·ª±c ph√≤ng trong th√°ng
            const tongDiemTrucPhong = data.diemTrucPhong.reduce((sum, score) => sum + score, 0);
            
            // T·ªïng ƒëi·ªÉm ph·∫°t c√° nh√¢n c·ªßa t·∫•t c·∫£ th√†nh vi√™n trong th√°ng
            const tongDiemPhatCaNhan = data.diemPhatCaNhan.reduce((sum, penalty) => sum + penalty, 0);
            
            // S·ªë l∆∞·ª£ng th√†nh vi√™n trong ph√≤ng
            const soThanhVien = this.roomMembers[room] || 1;
            
            // C√¥ng th·ª©c: (T·ªïng ƒëi·ªÉm tr·ª±c ph√≤ng - T·ªïng ƒëi·ªÉm ph·∫°t ph√≤ng) / S·ªë l∆∞·ª£ng th√†nh vi√™n
            const diemCuoiCung = (tongDiemTrucPhong - tongDiemPhatCaNhan) / soThanhVien;
            
            results.push({
                room: room,
                tongDiemTruc: tongDiemTrucPhong.toFixed(1),
                tongDiemPhat: tongDiemPhatCaNhan,
                soThanhVien: soThanhVien,
                diemCuoiCung: Math.max(0, diemCuoiCung).toFixed(1) // Kh√¥ng ƒë·ªÉ √¢m
            });
        });
        
        // S·∫Øp x·∫øp theo s·ªë ph√≤ng
        return results.sort((a, b) => {
            const roomA = parseInt(a.room) || 0;
            const roomB = parseInt(b.room) || 0;
            return roomA - roomB;
        });
    }

    // Render b·∫£ng th·ªëng k√™ th√°ng theo ph√≤ng
    renderMonthlyRoomTable(container) {
        const students = window.students || [];
        const months = Object.keys(this.monthlyData).sort();

        if (months.length === 0) {
            container.innerHTML = `
                <h2>üìÖ Th·ªëng k√™ th√°ng theo ph√≤ng</h2>
                <p>‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu th·ªëng k√™ th√°ng.</p>
            `;
            return;
        }

        // L·∫•y danh s√°ch t·∫•t c·∫£ c√°c ph√≤ng
        const allRooms = [...new Set(students.map(s => s.room))].sort((a, b) => {
            const roomA = parseInt(a) || 0;
            const roomB = parseInt(b) || 0;
            return roomA - roomB;
        });

        // Header
        let header = `
            <th style="width: 60px;">STT</th>
            <th style="width: 80px;">PH√íNG</th>
            <th style="width: 100px;">S·ªê TH√ÄNH VI√äN</th>
        `;
        months.forEach(month => {
            header += `<th style="background:#e3f2fd; min-width: 120px;">${this.monthLabels[month]}</th>`;
        });

        // Body
        const rows = allRooms.map((room, index) => {
            const memberCount = this.roomMembers[room] || 0;
            let cols = `
                <td style="text-align: center; font-weight: bold;">${index + 1}</td>
                <td style="text-align: center; font-weight: bold; color: #1976d2;">${room}</td>
                <td style="text-align: center;">${memberCount}</td>
            `;
            
            months.forEach(month => {
                const roomData = this.monthlyData[month][room];
                if (roomData) {
                    const stats = this.calculateMonthlyRoomStats({ [room]: roomData });
                    const roomStats = stats[0];
                    
                    cols += `
                        <td style="text-align: center; font-weight: bold; color: ${roomStats.diemCuoiCung >= 50 ? '#388e3c' : '#d32f2f'};">
                            ${roomStats.diemCuoiCung}
                        </td>
                    `;
                } else {
                    cols += `<td style="text-align: center; color: #999;">-</td>`;
                }
            });
            
            return `<tr>${cols}</tr>`;
        }).join("");

        // T√≠nh th·ªëng k√™ t·ªïng quan
        const totalRooms = allRooms.length;
        const totalStudents = students.length;
        const avgMembersPerRoom = totalRooms > 0 ? (totalStudents / totalRooms).toFixed(1) : 0;

        container.innerHTML = `
            <h2>üìÖ Th·ªëng k√™ th√°ng theo ph√≤ng</h2>
            <div class="stats-summary" style="margin-bottom: 16px; padding: 12px; background: #f5f5f5; border-radius: 6px; font-size: 14px;">
                <strong>T·ªïng quan:</strong> ${totalRooms} ph√≤ng | ${totalStudents} sinh vi√™n | 
                TB ${avgMembersPerRoom} SV/ph√≤ng | ${months.length} th√°ng c√≥ d·ªØ li·ªáu
                <br>
                <em>C√¥ng th·ª©c: (T·ªïng ƒëi·ªÉm tr·ª±c ph√≤ng - T·ªïng ƒëi·ªÉm ph·∫°t c√° nh√¢n) √∑ S·ªë th√†nh vi√™n (scale 0-55)</em>
            </div>
            <div class="excel-table-wrapper">
                <table class="excel-table">
                    <thead><tr>${header}</tr></thead>
                    <tbody>${rows}</tbody>
                </table>
            </div>
            <div style="margin-top: 12px; font-size: 12px; color: #666;">
                üü¢ M√†u xanh: ƒêi·ªÉm ‚â• 50 | üî¥ M√†u ƒë·ªè: ƒêi·ªÉm < 50
            </div>
        `;
    }

    // Public method: load tab th√°ng
    async loadMonthlyRoomStatsTab(container) {
        await this.loadMonthlyData(window.students || []);
        const months = Object.keys(this.monthlyData);

        if (months.length === 0) {
            container.innerHTML = `
                <h2>üìÖ Th·ªëng k√™ th√°ng theo ph√≤ng</h2>
                <p>‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu th·ªëng k√™ th√°ng.</p>
            `;
            return;
        }

        this.renderMonthlyRoomTable(container);
    }

    // Export d·ªØ li·ªáu th·ªëng k√™ th√°ng
    async exportMonthlyData() {
        try {
            await this.loadMonthlyData(window.students || []);
            const months = Object.keys(this.monthlyData).sort();
            const allRooms = [...new Set((window.students || []).map(s => s.room))].sort((a, b) => {
                const roomA = parseInt(a) || 0;
                const roomB = parseInt(b) || 0;
                return roomA - roomB;
            });

            const headers = ['STT', 'PH√íNG', 'S·ªê TH√ÄNH VI√äN'];
            months.forEach(month => headers.push(this.monthLabels[month]));

            const csvContent = [
                headers.join(','),
                ...allRooms.map((room, index) => {
                    const memberCount = this.roomMembers[room] || 0;
                    const row = [index + 1, room, memberCount];

                    months.forEach(month => {
                        const roomData = this.monthlyData[month][room];
                        if (roomData) {
                            const stats = this.calculateMonthlyRoomStats({ [room]: roomData });
                            row.push(stats[0].diemCuoiCung);
                        } else {
                            row.push('');
                        }
                    });

                    return row.join(',');
                })
            ].join('\n');

            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `thong_ke_thang_theo_phong_${new Date().toLocaleDateString('vi-VN').replace(/\//g, '_')}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        } catch (err) {
            console.error("‚ùå L·ªói export th·ªëng k√™ th√°ng:", err);
        }
    }
}

// T·∫°o instance global
const monthlyRoomStats = new MonthlyRoomStats();
window.loadMonthlyRoomStats = (container) => monthlyRoomStats.loadMonthlyRoomStatsTab(container);
window.exportMonthlyRoomStats = () => monthlyRoomStats.exportMonthlyData();